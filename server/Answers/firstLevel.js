module.exports = [
  {
    title: 'Программное обеспечение его классификация',
    answer: `Программное обеспечение или же “Software” (сокр. ПО) простым языком это множество или же одна программа, созданная для управления компьютера, ну или вычислительной техники.
    Сам термин ПО было введено в 60-х годах прошлого века. К слову примерно в то же время ПО индустрия начал становится самостоятельной отраслью.
    Современное ПО классифицируется по очень многим параметрам. Такие как:
    Вычислительная система или же среда работы. В наше наполненное технологиями и разными смарт девайсами время этот пункт как никак актуален.
    Не все пользователи одинаковые. И этот пункт — это разделение по умениям пользователя. Есть бабушки и дедушки, а есть и конкретные специалисты. И для каждого свой ПО.
    Частота обновлений ПО тоже один из пунктов классификаций. Есть как стабильные (обычно это LTS версий что означает и переводится как: Long Term Support – Долгосрочная поддержка) и тестовые версий, обновления которых могут выходит каждую неделю/месяц.
    Следующий это состояние ПО. То есть ПО может быть, как в раннем разработке или же уже готовым к использованию. Готовность ПО иначе говоря.
    Язык программирования тоже является пунктом классификаций ПО.
    Не все устройства одинаковые. Есть как дорогие и производительные, так и старые, и слабые. Это уже не факт, но это пункт классификаций.
    Масштабность тоже пункт классификаций ПО.
    Не все ПО подойдут для бытовой жизни. Так есть пункт по области применения.
    И это ещё не все классификаций, а только лишь основные.
    `,
  },
  {
    title: 'Основные окна работы программы EmbarcaderroRadStudio',
    answer: `Если вы работали до этого в таких программах как Visual Studio, QT Android Studio или же в других IDE для создания оконных программ под разные платформы, то для вас разобраться в RadStudio не составит особых проблем. Ведь он не является чем-то экзотическим и создан для удобства программистов.
    При запуске первое что вас встретит это окно проектов. Тут всё интуитивно понятно и просто. Есть блок с созданными проектами, если они есть.  А так же кнопки для создания нового проекта на языке программирование Delphi или же C++ Builder на выбор. Или можно загрузить проект локально или же с удалённого репозитория наподобие GitHub, GitLab или BitBucket.
    
    Далее после создания/открытия проекта у вас должно появится окно редактирования Формы (ПО).  В самой верхней части расположен стандартный toolbar с такими всплывающим меню как File, Edit, Project, Run Window которые отвечают на сохранение, настройки, внешний вид редактора, компиляция проекта. И это далеко не полный функционал.
    Далее идут иконки сохранения, запуска и кнопки для дебагинга.
    Следующие это отдельные окна, которых можно расставить под себя. Остановимся на основных.
    Окно Project – это окно для управления проектом. И здесь так же показывается иерархия проекта в которое можно вносить изменения.
    Tool Palette – название само говорит за себя. Тут собранно все компоненты вроде кнопок текстовых полей переключателей и т.д.
    Так же есть окно инспектора выбранного объекта. Тут в основном всего две вкладки — это Свойства и События. И их так же можно менять и настраивать. Если в общем, то тут размер, цвет, стили и различные события на которых можно повесить свой обработчик для большей интерактивности.
    Окно Структуры проекта. Тут даже сказать нечего. Структура текущей формы.
    И самое главное это окно с вкладками для работы с формой. Это можно сказать холст где вы создаёте UI своего приложения.
    В общем это все стандартные окна. И да всё это естественно может расходиться в зависимости от того с какой версией ПО вы сравниваете.
    `,
  },
  {
    title: 'Форма и его основные свойства и события',
    answer: `Форма это можно сказать контейнер для вашего пользовательского интерфейса. Внутрь которого можно настраивать под себя. И внутри одного проекта может находится более одной формы, управляя которыми можно здорово увеличить функционал и удобство вашего приложения.
    Основные свойства (для меня):
    Anchors – это свойство определяет якоря крепления при изменений размера для внутренних элементов.
    BorderIcons – В этом разделе можно включать и выключать Системное меню. То есть Системные кнопки сворачивания, на весь экран и закрытия. А так же иконка окна.
    Caption – Название окна что будет находится в вверху.
    Font – Это раздел для точной кастомизаций текста. От цвета до шрифта.
    Height – Высота.
    Width – Ширина окна.
    Icon – Иконка окна.
    Name – Это поле для установки имени. Позже через это имя можно взаимодействовать с формой через код.
    Visible – устанавливает видимость.
    Основные события:
    OnClick – при клике.
    OnClose – при закрытий.
    OnKeyPress – при нажатий на любую клавишу.
    OnDblClick – при двойном клике.
    Это не все свойства и события, а лишь те, которых я посчитал основными ведь они используется чаще остальных.
    `,
  },
  {
    title: 'Классы TBitmap TMetafile Ticon',
    answer: `TBitmap - это инкапсуляция растрового изображения Windows, включая его палитру. По другому это мощный графический объект, используемый для создания, обработки и хранения изображений в памяти и в виде файлов на диске. TBitmap содержит внутреннее изображение растровой графики и автоматически управляет реализацией палитры при отрисовке.
    TMetafile -  содержит графический метафайл (формат файла EMF). Свойства TMetafile указывают размер и характеристики метафайла. Чтобы нарисовать метафайл на холсте, нужно вызвать методы Draw или StretchDraw объекта TCanvas, передав TMetafile в качестве параметра.
    TIcon используется для представления одного из иконок в списке изображений. Можно назначить иконку объектам, у которых есть свойство Icon, например, TForm или TPicture. Объекты иконок представляют значение, загруженное из файла иконок Windows (файл .ICO). Можно нарисовать иконку на холсте, используя метод Draw объекта TCanvas.
    `,
  },
  {
    title: 'Панель Standard Компонент Button',
    answer: `Начнем с компонент, расположенных на закладке Standard – наиболее часто используемых в Windows-приложениях. Это текстовые надписи, кнопки, переключатели, текстовые поля, панели и иные повсеместно используемые элементы пользовательского интерфейса.
    Standard – стандартные компоненты; наиболее часто используются в приложениях
    команда New Items очень часто применяется для присоединения новой формы или модуля к проекту. 
    - аналог команды File > Reopen. Позволяет быстро открывать сохранённые на диске проекnы. Нажмите стрелочку справа от папки, чтобы раскрыть список последних проектов и файлов.
     - аналог команды File > Save (быстрые клавиши - Ctrl+S). 
    - аналог команды File > Save all (быстрые клавиши – Shift + Ctrl+S).
     - аналог команды File > Open Project (Ctrl+F11). Быстрое открытие сохранённого на диске проекта.
    TButton - стандартная кнопка.
    Пожалуй, самым важным элементом управления в любой программе является кнопка, ведь, фактически, без нажатия на кнопку не начинается ни одно действие в Windows-приложениях.
    Для создания этого элемента управления в VCL предусмотрено несколько компонент, но наиболее востребованным является Button (кнопка). Он находится на закладке Standard палитры компонентов.
    `,
  },
  {
    title: 'Memo и RichEdit многострочные окна редактирования',
    answer: `Компонент Memo – это многострочное окно редактирования текста. Компонент Memo обладает теми же функциями, что и Edit. Для быстрого редактирования текста имеются комбинации «горячих» клавиш:
      Ctrl+C – копирование выделенного текста.
      Ctrl+V – вставка текста.
      Ctrl+X – вырезание выделенного текста.
      Ctrl+Z – отмена последней команды редактирования.
    Свойство Font компонента Memo одинаковый формат (шрифт и его атрибуты) для всего текста. Отредактированный текст при копировании из окна Memo не будет содержать элементы форматирования. Или отредактированный текст скопированный, например, из Word с элементами форматирования, то при вставке в окно Memo, будет вставлен как текст и к нему применяться те стили, которые указаны в свойстве Font.
    Компонент RichEdit – это удобное многострочное окно редактирования текста. Компонент RichEdit имеет большинство функций компонентов Memo и Edit. Так же есть наличие комбинации «горячих» клавиш. Окно редактирования RichEdit обладает множеством сообщений Windows, которые позволяют управлять текстом.
    Компонент RichEdit позволяет редактировать текст формате RTF. Свойство SelAttributes типа TTextAttributes позволяет менять атрибуты добавляемого текста и имеет ряд подсвойств:
      Color – устанавливает цвет текста.
      Name – устанавливает имя шрифта.
      Size – устанавливает размер.
      Style – определяет стиль текста.
    С помощью диалога выбора шрифта FontDialog можно легко менять атрибуты текста в RichEdit.
    `,
  },
  {
    title: 'Работа с несколькими формами',
    answer: `Редкая программа обходится одной формой. Мы можем с лёгкостью создавать дополнительные формы Rad Studio, предоставляющие возможность, например, вести диалог с пользователем, принимать и выводить любую необходимую информацию. В этом уроке научимся создавать несколько форм Rad studio дополнительно к основной.  Все новые формы автоматически заносятся в разряд автосоздаваемых, то есть в начале работы программы они будут автоматически создаваться сразу, одновременно с первой, главной Формой проекта. Нам не придётся этим заниматься в программе, но одновременное создание многих форм занимает ресурсы и время программы. Теперь разберёмся в разнице между обычными и модальными Формами. Обычные Формы позволяют свободно переходить между всеми Формами, находящимися в данный момент на экране. Модальная Форма в момент вызова блокирует переход между Формами проекта до тех пор, пока не будет закрыта, и работа возможна только в ней.
    Для доступа из одной Формы как к свойствам другой Формы, так и к свойствам её компонентов необходимо указывать имя Формы, к которой мы обращаемся. Мы также имеем доступ к данным, использующимся в модуле, описывающим её работу. Для этого необходимо указывать уже имя модуля. Например, для обращения к переменной X из модуля Unit2 пишем так: Unit2.X
    `,
  },
  {
    title: 'Таблица строк-компонент StringGrid',
    answer: `Компонент StringGrid находится на странице Additional палитры компонентов. Там находятся "дополнительные" компоненты, но StringGrid Delphi, на мой взгляд, достоин большего уважения, лично я разместил бы его на странице Standart!

      StringGrid - компонент для отображения различных данных в табличной форме. Как следует из названия, ячейки компонента StringGrid Delphi могут содержать данные, имеющие тип String, а также отображать графику.
      Таблица StringGrid состоит из выделенных серым FixedCols и FixedRows - зафиксированных ячеек-заголовков, и обычных, белых ячеек. Содержимое Fixed ячеек недоступно редактированию, и меняется только программно. За возможность редактирования обычных ячеек отвечает одно из значений свойства Options.

      Итак, компонент StringGrid имеет возможность адресации каждой отдельной ячейки по номеру столбца и строки. Содержимое ячейки (i, j), где где i - номер столбца, j - номер строки, имеет вид
  
      StringGrid1.Cells[i, j]
  
      и доступно как для чтения, так и для записи. Здесь, как и всегда, номера столбцов ( i ) и строк ( j ) отсчитываются от 0.
  
      Выделенная ячейка таблицы имеет
      номер столбца:	   StringGrid1.Col
      номер строки:	   StringGrid1.Row    
    `,
  },
  {
    title: 'Класс Tbrush',
    answer: `Этот класс предназначен для инкапсуляции свойств щеточного инструмента для заполнения зон. При создании экземпляра этого класса сначала используется белая жесткая (Style=bsSolid) кисть. Кисть представляет цвет и рисунок, используемые для заливки сплошных фигур. Кисть инкапсулирует объект кисти Windows (КИСТЬ) и используется для заливки сплошных фигур, таких как прямоугольники и эллипсы, цветом или рисунком. Объект кисти - это вспомогательный объект, представляющий кисть, используемую для рисования фона фигуры, отображаемой компонентом TShape. Используя свойство Color, вы можете получить или задать цвет кисти. Свойство Style позволяет указать шаблон цвета фона.
      Свойства кисти:
          Имя                               Описание 
        Color-                      Определяет цвет кисти.
        Property-                   Получает или устанавливает значение свойства, указанного его индексом.
        PropertyByName-             Получает или задает значение свойства с указанным именем.
        PropertyCount-              Возвращает количество свойств объекта.
        PropertyName-               Возвращает имя свойства по индексу.
        Style-                      Определяет рисунок кисти.

      Объекты класса Brush используются для заполнения внутреннего пространства замкнутых фигур. Первоначально создается белая сплошная (bsSolid) кисть. Свойства этого класса заключаются в следующем:
        property Bitmap: TBitmap; - содержит растровое изображение, которое будет использоваться кистью для заполнения. Если это свойство определено, свойства Color и Style игнорируются;
        property Color: TColor; - цвет кисти;
        property Handle: Integer; - дескриптор кисти. Используется при непосредственном обращении к API-функциям Windows;
        property Style: TBrushStyle; - стиль кисти. Возможные значения:
          bsSolid - сплошная штриховка;
          bsClear - штриховка цветом фона (стирание линии);
          bsBDiagonal - штриховка диагональными линиями (///);
          bsFDiagonal - штриховка диагональными линиями (\\\);
          bsCross - штриховка "клеточками";
          bsDiagCross - штриховка "крестиками" (ххх);
          bsHorizontal - штриховка горизонтальными линиями;
          bsVertical - штриховка вертикальными линиями.
    `,
  },
  {
    title: 'Класс Tfont',
    answer: `Класс инкапсулирует шрифт Windows. В Delphi разрешены только горизонтально расположенные шрифты. В конструкторе объектов по умолчанию принимается системный шрифт, цвета и размер текста ciwindow 10 элементов.Объект типа Tfont определяет множество характеристик, характеризующих шрифт, используемый при отображении текстов, высоты шрифта, его названия, атрибутов (жирный шрифт, курсив) и т. д.
      Используя класс Tfont, объект шрифта создается для любого графического устройства (экрана, принтера, плоттера и т. д.). В Delphi разрешены только горизонтально расположенные шрифты. В конструкторе объектов по умолчанию принимается 10-точечный системный шрифт clwindowtext.
      Основным свойством объекта Font name является имя. Если используется шрифт с несколькими наборами символов, то свойство Charset-набор символов должен быть установлен правильно.
      Если указанная комбинация имени собственности, кодирования, тона, размера определяет шрифт, которого нет в системе, Windows выберет другой близкий шрифт.
      При создании объекта Tfont он инициализируется со следующими значениями свойств:
      Цвет = Clwindowtext, имя = MS sans-serif, размер-8, по умолчанию = FP, кодировка = DEFAULT_CHARSET. Значение пикселя на дюйм устанавливается автоматически.
    `,
  },
  {
    title: 'Методы класса Tcanvas',
    answer: `TCanvas предоставляет абстрактное пространство для рисования для объектов, которые должны отображать свои собственные изображения.

      Используйте TCanvas как поверхность для рисования для объектов, которые рисуют изображение самих себя. Стандартные оконные элементы управления, такие как элементы управления редактированием или списки, не требуют холста, поскольку они рисуются системой.
      
      TCanvas предоставляет свойства, события и методы, которые помогают в создании изображения:
      
      Указание типа кисти, пера и шрифта для использования.
      Рисование и заливка разнообразных форм и линий.
      Написание текста.
      Визуализация графических изображений.
      Включение реакции на изменения в текущем изображении.
      TCanvas имеет двух потомков, TControlCanvas и TMetafileCanvas, которые помогают рисовать изображения элементов управления и создавать изображения метафайлов для объектов.
      Основые методы класса TCanvas:
        процедура moveTo (X, Y: Целое число); - перо помещается в одну точку. X, Y (это необходимо перед тем, как вы начнете рисовать некоторые линии, например, отрезок прямой линии - см. Линия К)
        процедура lineTo (X, Y: Целое число); - отрезок прямой линии проводится шнуром через точку. X, Y (см. moveTo) Эллипс
        Процедура fillRect (const Rect: трассировка); - заполните прямоугольный прямоугольник Свойства фона должны быть заданы с помощью Canvas.Кисть (см. раздел свойства, кисть)
    `,
  },
  {
    title: 'Создание основного и контекстного меню Компонент TmainMenu',
    answer: `Характеристики
      Тип - класс	
      Видимость - общественный	
      Источник - Vcl.Menus.pas Vcl.Menus.hpp
      Единица измерения - Vcl.Menus
      Родитель - Vcl.Menus
      TMainMenu инкапсулирует строку меню и сопровождающие ее раскрывающиеся меню для формы. Используйте TMainMenu для создания главного меню формы. Чтобы начать разработку меню, добавьте в форму главное меню и дважды щелкните компонент. TMainMenu представляет свойства и методы для объединения раскрывающихся меню главного меню с главным меню другой формы. TMainMenu представляет свойства и методы для помощи в процессе согласования меню OLE-контейнера. Совет: чтобы создать меню, которое пользователи могут настраивать во время выполнения, используйте вместо этого компонент TActionMainMenuBar с диспетчером действий.
    `,
  },
  {
    title: 'Инспектор объектов',
    answer: `Просмотр> Окна инструментов> Инспектор объектов
      Инспектор объектов отображает имена и текущие значения свойств и событий, связанных с выбранным объектом.
      Используйте инспектор объектов для проверки и редактирования свойств и событий для текущего выбранного объекта или объектов. F11повторно открывает инспектор объектов .
      F11перемещает фокус в поле фильтра в инспекторе объектов и переключает между инспектором объектов и последней активной формой или файлом редактора кода . Используйте инспектор объектов для редактирования значений свойств и ссылок на обработчики событий.
      Вкладка Характеристики - Отображает свойства выбранного объекта в форме.
      Вкладка События - Отображает события для выбранного объекта в форме.
      Настройте инспектор объектов, используя меню « Показать» в контекстном меню.
      Новый параметр « Показать» позволяет отображать или скрывать различные части Инспектора объектов
    `,
  },
  {
    title: 'Библиотека визуальных компонентов',
    answer: `RAD Studio предлагает мощную интегрированную среду разработки, которая упрощает создание собственных приложений Windows. Библиотека визуальных компонентов (также известная как VCL ) предлагает большое количество визуальных и невизуальных элементов управления и компонентов, которые можно использовать для создания практически любого желаемого пользовательского интерфейса. 
      Наиболее важные преимущества VCL перед другими конкурирующими технологиями заключаются в следующем:
      1.	Стандартный набор компонентов, включающий все элементы управления, предоставляемые платформой пользовательского интерфейса Windows. 
      2.	Расширенный набор компонентов, обычно не представленных в среде пользовательского интерфейса Windows. 
      3.	Действия - ключевая концепция, широко используемая в приложениях VCL, - позволяют централизовать всю логику взаимодействия вашего пользовательского интерфейса.
      4.	Ряд элементов управления с учетом данных, которые можно связать с источником данных во время разработки. 
      5.	Фреймворки баз данных DBExpress и dbGo. Эти фреймворки можно использовать со всеми элементами управления, учитывающими данные, что упрощает разработку приложений больше, чем когда-либо. 
      6.	Internet Direct, также известный как Indy, предоставляет большое количество компонентов, используемых в приложениях, подключенных к Интернету. 
      7.	DataSnap, позволяющий создавать распределенные приложения.
    `,
  },
  {
    title: 'Окна редактирования Edit Label MaskEdit',
    answer: `Компонент Edit-это простое окно редактирования, которое позволяет вводить и отображать текстовую информацию в свойстве Text типа AnsiString, но имеет много полезных функций. Компонент Edit поддерживает популярные сочетания горячих клавиш: Ctrl+C (копирование текста), Ctrl+X (обрезка текста), Ctrl+V (вставка текста), Ctrl+Z (Отмена редактирования последнего текста).
      Текст не может быть выровнен в поле редактирования, и он выравнивается слева. Дороги давать тоже нельзя. Текст, который не соответствует длине окна Edit, перемещается за пределы круга, и для его отображения достаточно переместить курсор мыши в сторону.
      Комбинация компонентов Edit и Label объекта класса Tboundlabel, представленного свойством EditLabel, называется компонентом LabeledEdit. Этот компонент поддерживает все свойства текстовой метки Label, которые можно найти здесь.
      Компонент LabeledEdit впервые включен в C ++ Builder 6. Благодаря ему разработка приложений стала намного проще. Он часто используется вместе с меткой, чтобы объяснить назначение окна редактирования.
      Компонент LabeledEdit имеет все свойства компонентов Edit и Label.
      
      Другой компонент, похожий на Edit и LabeledEdit, - это компонент MaskEdit. В отличие от компонентов Edit и LabeledEdit, он позволяет устанавливать маску.
      Маска состоит из трех частей:
      Первый раздел содержит специальные символы и символы маски, которые разрешено вводить в каждой позиции.
      Второй раздел проверяет, истинно или ложно, то есть нужно ли добавлять символы маски в свойство Text компонента MaskEdit.
      В третьем разделе необходимо указать символ, соответствующий позиции, которая не была введена.
    `,
  },
  {
    title: 'Компоненты выбора TCheckBox TRadioButton',
    answer: `TcheckBox и TRadioButton - это элементы для выбора. TCheckBox позволяют пользователю выбирать элементы из фиксированного числа альтернатив, в то время как переключатели позволяют пользователю выбрать ровно один элемент из списка нескольких предопределенных альтернатив.

      TCheckBox 
      TCheckBox используются для одновременного выбора любого количества опций из ограниченного числа опций.
      Вы можете выбрать ни одного, один или столько вариантов, сколько хотите, в группе флажков.
      Также может быть только один флажок.
      Выберите имя, которое четко различает два разных состояния или контрастов.
      TRadioButton 
      TRadioButton используются для выбора одного варианта из ограниченного числа вариантов.
      Располагайте переключатели в группы (вы определяете графические группы в Screen Painter). Поместите хотя бы две радиокнопки в одну группу.
      Всегда должен быть выбран один переключатель в группе.
      Если у пользователя должна быть возможность выбрать ни один элемент из предложенных вариантов, создайте отдельный переключатель с меткой «Без выбора» или аналогичным текстом, который отключает другие параметры, связанные с содержимым.
    `,
  },
  {
    title: 'Компоненты выбор из списка Tlistbox TcomboBox',
    answer: `Компоненты ListBox и ComboBox также широко используются. Компонент ListBox представляет собой стандартный список Windows, который просто представляет список вариантов, из которых пользователь может выбирать. Если список содержит больше элементов, чем может быть отображено за один раз, появляются полосы прокрутки, позволяющие получить доступ к остальным элементам в списке.
      ListBox Содержит индекс текущего выбранного элемента, где 0 является первым элементом в списке. Возвращает -1, если ни один элемент не выбран. При записи выбирает указанный индекс.
      ListBox Содержит количество элементов, выбранных в списке с множественным выбором.
      ListBox Возвращает истину, если указанный элемент выбран, или ложь, если нет.
      ComboBox Содержит длину текста, выбранного в данный момент в элементе управления редактированием поля со списком.
      ComboBox Содержит начальную точку выделенного текста в элементе управления редактирования. Первый символ в поле редактирования - 0.
      ComboBox Содержит текущий выделенный текст в поле редактирования.
      ListBox Возвращает элемент списка, который находится вверху списка. Может использоваться для установки верхнего элемента на определенный элемент списка.
    `,
  },
  {
    title: 'Компоненты TScrollbar TGroupBox',
    answer: `TScrollBar
      Этот компонент часто является частью других компонентов - как простая полоса прокрутки. Но время от времени вы должны позволять пользователю что-то перемещать. Вот когда вы используете этот компонент.
      Важные свойства и события:
      Минимум и Максимум - диапазон
      Позиция - текущая позиция
      SmallChange - изменение, вносимое нажатием клавиш со стрелками
      LargeChange - изменение, производимое нажатием на пустые места на полосе прокрутки
      OnChange - событие, вызываемое при внесении пользователем изменений.
      
      Иногда целесообразно разделить компоненты друг от друга или необходимо поместить на форму больше компонентов, чем ее вместимость.
      Первую проблему решают компоненты TPanel и TGroupBox. Оба работают как контейнер для других компонентов (включая другие TPanels). Важно то, что если вы помещаете компонент на панель, координаты этого компонента связаны с положением этой панели, и поэтому, если вы меняете положение этой панели, все компоненты перемещаются автоматически.
      TPanel и TGroupBox отличаются внешним видом, где TPanel часто используется как невидимый контейнер (он устанавливает для свойства Bevel * значение bvNone и Caption для пустого текста), тогда как TGroupBox используется для визуального выделения групп компонентов.
      Если вы установите Visible: = False, все компоненты в панели или групповом ящике станут невидимыми. То же самое и для Enabled.
      По сравнению с этими двумя компонентами TRadioGroup - особый компонент. Проще говоря, это панель с группой TRadioButtons, которые определяются через свойство Items, а выбранный элемент доступен через ItemIndex. То же самое можно сделать с помощью комбинации TGroupBox и группы TRadioButton, но это более трудоемко.
    `,
  },
  {
    title: 'Компоненты TPanel TScrollBox',
    answer: `Компонент TPanel предоставляет общий контейнер для других элементов управления. Панели обычно используются для визуального группирования компонентов на форме. Панели могут быть выровнены по форме для сохранения того же относительного положения при изменении размера формы. Свойство BorderWidth определяет ширину в пикселях границы вокруг панели.
      Вы также можете разместить другие элементы управления на панели и использовать свойство Align, чтобы обеспечить правильное расположение всех элементов управления в группе на форме. Вы можете выровнять панель по верхнему краю так, чтобы ее положение оставалось на месте даже при изменении размера формы.
      Внешний вид панели можно изменить на приподнятый или опущенный с помощью свойств BevelOuter и BevelInner . Вы можете изменять значения этих свойств для создания различных визуальных трехмерных эффектов. Обратите внимание: если вам просто нужен приподнятый или опущенный скос, вы можете вместо этого использовать менее ресурсоемкий элемент управления TBevel .
      Вы также можете использовать одну или несколько панелей для создания различных строк состояния или областей отображения информации.TScrollBox представляет собой область прокрутки (поле прокрутки) в окне.
      Используйте TScrollBox, чтобы создать полосу прокрутки в окне.
      Поле прокрутки можно использовать для предотвращения прокрутки областей окна, таких как панель инструментов или строка состояния, построенная с помощью компонентов TPanel. Чтобы предотвратить прокрутку панели инструментов и строки состояния, скройте полосы прокрутки окна, а затем поместите полосу прокрутки в клиентской области окна между панелью инструментов и строкой состояния. Полосы прокрутки, связанные с полем прокрутки, будут отображаться как принадлежащие окну, но будут прокручивать только область внутри поля прокрутки.
      Еще одно использование полей прокрутки - создание нескольких областей прокрутки (представлений) в окне. Представления распространены в коммерческих текстовых редакторах, электронных таблицах и приложениях для управления проектами.
    `,
  },
  {
    title: 'Вывод сообщений Процедуры ShowMessage MessageBox',
    answer: `Функция ShowMessage() предоставляет наиболее фундаментальные окна сообщений Embarcadero. Эта функция принимает один строковый аргумент и не возвращает никакого значения. Он используется для отображения сообщения пользователю, который подтверждает его нажатием кнопки "ОК". Синтаксис функции ShowMessage() таков:

      procedure ShowMessage(const Msg: string);
      
      Окно сообщения, созданное с помощью функции ShowMessage(), использует название проекта в качестве подписи. Отображаемое сообщение представляет собой строку, которая может быть предоставлена разработчиком. 
      
      MessageBox - это относительно небольшое диалоговое окно, используемое для отображения сообщения и предоставления одной или нескольких кнопок.
      MessageBox используется для предоставления информации пользователю или для запроса решения (от пользователя). Нажав кнопку или одну из кнопок (если в окне сообщения отображается более одной), пользователь принимает решение, и программа продолжается.
      MessageBox создаются с помощью встроенных функций из VCL и библиотеки Win32. Необходимые функции поставляются вместе с компилятором.
    `,
  },
  {
    title: 'Панель Additional',
    answer: `На странице Additional расположены дополнительные компоненты, без некоторых из которых сложно представить Windows: кнопки с дополнительными свойствами, таблицы, компоненты для размещения изображений и многие другие, представленные в таблице:
      BitBtn
      Командная кнопка. От стандартной кнопки отличается возможностью отображения значка кнопки.
      
      SpedButton
      Пиктографическая кнопка. Обычно используется для быстрого доступа к параметрам главного меню.
      
      StringGrid
      Строки таблицы. Этот компонент обладает мощными возможностями для представления текстовой информации в табличной форме.
      
      DrawGrid
      Картинный стол. Этот компонент используется для отображения изображений в табличной форме.
      Изображение компонента Delphi Изображение Изображение. Компонент для отображения изображений, включая значки и метафайлы.
      
      Shape
      Фигура. С помощью этого компонента вы можете нарисовать правильную форму на фигуре - прямоугольник, эллипс, круг.
      
      Bevel
      Служит для разделения отдельных частей формы объемными рамками и полосами.
      
      ScrollBox
      Панель с полосами прокрутки. В отличие от компонента панели, он автоматически вставляет полосы прокрутки, если размещенные на нем компоненты пересекают его границы.
      
      CheckListBox
      Списки с множественным выбором. Он отличается от стандартного компонента ListBox тем, что переключатель CheckBox находится рядом с каждым параметром, что упрощает выбор нескольких параметров одновременно.
      
      Splitter
      Границы. Этот компонент создает границу между двумя видимыми компонентами и позволяет пользователю перемещать ее.
      
      StaticText
      Статический текст. Он отличается от стандартного компонента Label тем, что имеет собственное окно Windows, которое позволяет округлять текст рамкой или выделять его как «вдавленную» часть формы.
      
      Chart
      Диаграмма. Этот компонент упрощает создание настраиваемых панелей для графического отображения данных.
    `,
  },
  {
    title: 'Вставка картин и изображений в приложение Компонент Image',
    answer: `Компонент Image для отображения изображения из файлов, которые заканчиваются расширениями, включая ICO, BMP, WMF, WMF, GIF и JPG. Свойство Picture определяет изображение, которое отображается в элементе управления изображением. Delphi поддерживает несколько различных методов назначения изображения для компонента TImage: в методе изображения LoadFromFile считывается графика с диска или метод назначения получает изображение из буфера обмена.
      Свойства
      Center - Устанавливает изображение в центре
      Stretch - Показывает изображение в режиме растягивания
      Transparet - Устанавливает прозрачный фон
      Proportional - Указывает, следует ли изменять изображение без искажений.
      Picture - Для загрузки сохраните изображение в системе управления изображениями
      
      onClick - Когда пользователь нажимает на изображение в процессе
      onProgress - Когда изображение вот-вот будет обработано или очищено. Это может быть использовано для отображения процентов в случае медленного процесса.
    `,
  },
  {
    title: 'Работа с несколькими формами',
    answer: `Уникальность 0% сатья с инета!!!
    Нужно к главной форме Form1 добавить новую форму Form2 в приложении.

      В главной форме Form1:
      
      создать кнопку «Show Form — 2» для вызова новой формы;
      вывести сообщение в Form1 о результате возврата из Form2.
      В новой форме Form2:
      
      создать две кнопки с названиями «OK» и «Cancel»;
      запрограммировать реакцию формы на нажатие мышкой (клавиатурой) на соответствующей кнопке.

      Выполнение
      1. Запустить Embarcadero Delphi 2010. Создать проект по шаблону VCL Forms Application
      Подробный пример создания нового проекта по шаблону VCL Forms Application описывается здесь.
      
      Сохранить проект и главную форму с именем «MainForm» в некоторую папку. Автоматически главной форме присваивается имя Form1 (свойство Name в Object Inspector).

      2. Проектирование главной формы Form1
      Вынести на главную форму компоненты типа TLabel и TButton. Соответственно имена компонент будут Label1 и Button1.
      
      В свойстве «Caption» компонента Label1 вписываем текст «Result =». В свойстве «Caption» компонента Button1 вписываем текст «Show Form 2».
      
      
      Главная форма проекта имеет вид, изображенный на рисунке 2.

      3. Добавление новой формы в проект
      Новая форма в проект добавляется путем вызова последовательности комманд (рис. 3):
      
      File -> New -> Form Delphi
      
      
      В результате, на экране появится новая пустая форма (рис. 4). Получить доступ к свойствам и методам (процедурам и функциям) этой формы можно с помощью имени Form2 по умолчанию.
      
      В Object Inspector имя формы отображается в свойстве Name. По желанию можно изменить название формы.
      
      Сохранить новую форму в файле можно с помощью команды
      
      File -> Save All
      Каждая новая форма сохраняется в отдельном файле (модуле). По умолчанию Delphi предлагает имя Unit2.pas. Оставим все как есть.      
      Автоматически, кроме модуля Unit2.pas, создается файл описания формы Unit2.dfm.
      Таким образом, имеем две формы с такими же именами в программе (свойство «Name»):
      
      Form1 — основная форма (размещается в модуле MainForm.pas);
      Form2 — второстепенная форма (размещается в модуле Unit2.pas).

      4. Настройка вида новой формы
      Для настройки корректного вида новой формы (Form2) выполняем следующие действия.
      
      Выносим на форму две кнопки (компонент типа TButton) и одну метку (TLabel). Получаем три переменные-компоненты с такими именами: Button1, Button2, Label1.
      Свойство Caption компонента Button1 устанавливаем в значение «OK».
      Свойство Caption компонента Button2 устанавливаем в значение «Cancel».
      Свойство Caption компонента Label1 устанавливаем в значение «Form — 2».
      По желанию можно настроить и другие свойства формы Form2.
   
      5. Подключение формы 2 к модулю формы 1
      Для того, чтобы получить результат возврата из формы 2 (Form2) или иметь доступ к методам или свойствам формы 2 нужно подключить ее к главной форме.
      Это осуществляется с помощью директивы uses в начале текста модуля главной формы в разделе implementation.
      
      ...
      implementation
      
      uses Unit2;
      
      ...
      
      end.
    
      
      6. Вызов дочерней формы из главной формы
      Для вызова дочерней формы (Form2) программируем событие клика мышкой на кнопке «Show Form 2″.
      Листинг программного кода этого события следующий.
      
      procedure TForm1.Button1Click(Sender: TObject);
      var
      res:word;
      begin
        // вызываем дочернюю форму
        res := Form2.ShowModal; 
        if res=mrOk then
          Label1.Caption := 'Result = OK'
        else
          Label1.Caption := 'Result = Cancel';
      end;
      
      
      Непосредственный вызов дочерней формы осуществляется с помощью функции ShowModal, возвращающей одно из двух значений (см. п. 7):
      
      mrOk – означает, что в дочерней форме Form2 нажата кнопка «OK«;
      mrNo – означает, что в дочерней форме Form2 выбрано «Cancel«.
      
      
      7. Программирование событий в форме 2
      Главной задачей есть определение того, какую кнопку нажал пользователь в дочерней форме Form2. От этого зависит выполнение программы. Например, если выбрана кнопка «OK», то это может означать выполнение каких-либо действий (чтение из файла, вывод на печать и т.д.).     
      В нашем случае программируем два события в модуле формы 2 (Unit2.pas):
      
      клик мышью на кнопке «OK» (Button1);
      клик мышью на кнопке «Cancel» (Button2).
      Листинг программного кода обработки этих событий имеет вид.
      
      procedure TForm2.Button1Click(Sender: TObject);
      begin
        // закрытие формы с кодом возврата mrOk
        ModalResult := mrOk; 
      end;
      
      procedure TForm2.Button2Click(Sender: TObject);
      begin
        // закрытие формы с кодом возврата mrNo
        ModalResult := mrNo; 
      end;
      
      
      Внешняя глобальная переменная ModalResult формы Form2 определяет поведение формы. Как только ModalResult становится равным ненулевому значению (mrOk или mrNo), то форма закрывается с соответствующим кодом возврата.
      
      В результате вызова из главной формы функции
      
      Form2.ShowModal;
      дочерняя форма 2 будет отображена на экране до тех пор, пока пользователь не закроет ее стандартными средствами Windows.
      
      Если пользователь выбрал кнопку «OK», то ShowModal возвратит значение mrOk. В другом случае ShowModal возвратит значение mrNo.
      
      Теперь можно запустить программу на выполнение и протестировать ее.
    `,
  },
  {
    title: 'Командная кнопка BitBtn',
    answer: `Компонент кнопки (TBitBtn) - это тип кнопки, который отличается от TButton тем, что вы можете отображать значки.
      Характеристики
      Устанавливает тип кнопки Kind.
      Глиф Если вам не нравятся предложенные рисунки, вы можете выбрать другие. Откроется диалоговое окно, в котором нужно указать путь к этому изображению.
      Margin Определяет расстояние от края кнопки до изображения (в пикселях). По умолчанию -1. В этом случае изображение и текст находятся в центре.
      Макет определяет положение изображения на кнопке. Вы можете выбрать: blglyphleft file - слева. blglyphright справа.
      Интервал Определяет расстояние в пикселях между изображением и текстом кнопки.
    `,
  },
  {
    title: 'Панель DIALOGS ',
    answer: `Панель Dialogs содержит несколько невизуальных компонентов, которые позволяют программе использовать стандартные диалоговые окна Windows, такие как окна выбора и хранения файла или изображения, окна выбора цвета и шрифта, окно настроек принтера и многое другое.
      Эти компоненты не предназначены для выполнения определенных действий: загрузки файла, печати, изменения текущего шрифта и т. Д. Они используются только для получения от пользователя требуемых значений параметров, например, поиска, указания шрифта, ввода полного имени файла, указав количество напечатанных страниц.`,
  },
  {
    title: 'Компоненты TOpenDialog  TsaveDialog',
    answer: `Свойства и события класса TOpenOialog перечислены ниже.
    DefaultExt
    Расширение имени по умолчанию. Если расширение не указано, оно добавляется в конец имени файла, выбранного пользователем.
    
    FileName
    Имя файла, выбранное пользователем вместе с путем полного поиска.
    Файлы Список выбранных имен файлов. Параметры должны иметь флажок
    ofAllowMultiSelect
    
    Filter
    Набор масок с выбранными именами файлов для отображения в диалоговом окне. Каждая маска состоит из двух частей: имени и
    образец, разделенный символом. Может соответствовать одному имени
    несколько примеров. Маски разделены символами
    
    Fitterlndex
    Текущий номер маски. Нумерация начинается с 1
    
    HistoryList
    Список ранее выбранных файлов (тип tstrings)
    
    InitialDir
    Текущий каталог, который отображается при первом открытии содержимого.
    чат
    Options
    Набор флажков, определяющих работу окна выбора файла
    Title
    Заголовок диалогового окна
    
    OnCanClose
    Пользователь пытается закрыть диалоговое окно. Редактор этого события позволяет вам проверить действительность окна имени файла, выбранного или введенного в соответствующий шлюз, а также разрешить или запретить его.
    
    OnFolderChange
    Пользователь перешел в другой каталог
    
    OnIncludeItem
    
    Новое имя добавляется к текущему списку файлов в диалоговом окне. Это позволяет вам выбирать имена, которые разрешены алгоритмом, определенным обработчиком событий.
    
    OnSelectionChange
    Пользователь выбрал новое имя файла в диалоговом окне.
    
    OnTypeChange
    Пользователь выбрал новую маску файла (свойство фильтра)
    
    SaveDialog-визуальный компонент. Он используется для выбора пользователем имени файла для сохранения.
    Компонент Delphi SaveDialog может работать с любым типом файлов для поддержки хранения файлов невизуальных компонентов. При доступе к этому компоненту вызывается диалоговое окно «Сохранить стандартный файл».
    Этот компонент такой же, как и компонент opendialog, поэтому здесь мало что написано, все упоминается в предыдущей статье.
    Ключевая особенность:
    Title  - используется для установки заголовка диалога;
    FileName - возвращает имя файла по умолчанию для хранения (иначе поле File Name будет пустым);
    DefaultExt - указывает расширение, которое будет добавлено к имени отдельного файла при печати вручную (а не выбрано из списка файлов). Если этих фильтров расширения два или больше, это значение игнорируется. Их необходимо поместить в раскрывающийся список значений расширений;
    Только Filter позволяет указать и выбрать определенные типы файлов.
    FilterIndex-first определяет, какой фильтр открыть.
    Устанавливает исходный каталог в диалоговом окне InitialDir.`,
  },
  {
    title: 'Компоненты  TFONTDialog TcolorDialog',
    answer: `Компонент Delphi fontdialog отображает диалоговое окно выбора шрифта по умолчанию. Диалог позволяет выбрать один из шрифтов, установленных в операционной системе, и настроить его основные параметры.
      Внешний вид и возможности окна выбора шрифта зависят в первую очередь от программистов выбранных опций.
      FDANSIONLY отображает только шрифты с кодировкой ansi
      В диалоговом окне fdApplyButton отображается кнопка «Заменить». Наличие этой кнопки разрешает диалоговое событие onApply.
      В диалоговом окне fdeffects установите флажок и подчеркните список выбора цвета шрифта.
      fdFixedPitchOnly Добавлять ко всем символам только шрифты одинаковой ширины
      fdForceFontExist позволяет ввести имя шрифта для поля ввода. Если пользователь вводит имя, которого нет в списке, появляется сообщение об ошибке.
      fdLimitSize Работает со свойствами диалогового окна MaxFontSize и MinFontSize, ограничивает диапазон размеров шрифта
      fdnofacesel Шрифт по умолчанию не устанавливается при вызове диалога из списка выбора
      Шрифты с набором OEM-символов удаляются из списка шрифтов, указанного в FDNOOEMFONTS.
      fdNoSimulations отображает только шрифты и шрифты, которые предоставляются непосредственно с файлом создания шрифта. Стили, синтезированные GDI Windows, не входят в список доступных шрифтов.
      Размер шрифта по умолчанию не устанавливается при выборе диалогового окна fdnosizesel.
      Стиль шрифта не устанавливается при вызове диалога fdnostylesel
      fdNoVectorFonts Извлекает все векторные шрифты из списка выбора
      fdScalableOnly отображает только масштабируемые шрифты, точечные шрифты удаляются из списка
      fdShowHelp Отображает кнопку справки
      fdTrueTypeOnly отображает только шрифты TrueType
      fdWysiwyg показывает только шрифты, доступные на принтере и экране
      
      Компонент Delphi ColorDialog формирует диалоговое окно User Color Selection. Здесь вы можете выбрать цвет из основной палитры, а также открыть дополнительную панель для выбора неосновного цвета. Вы можете добавить выбранный вами цвет к дополнительным цветам, используя кнопку «Добавить в пакет», чтобы сохранить его и использовать в будущем.
      
      Цвет свойства: TColor; Включает цвет по вашему выбору
      свойство CustomColors: TStrings; Включает выбранные пользователем цвета (до 16 цветов). Каждый формат строки имеет следующее <название цвета> = <шестнадцатеричное значение цвета RGB>, где название цвета от ColorA (первый цвет) до цвета (последний, шестнадцатый цвет). Пример Color = 985345
      TColorDialogOption = (cdFullOpen, cdPreventFullOpen, cdShowHelp, cdSolidColor, cdAnyColor);
      TColorDialogOptions = set of TColorDialogOption;
      Параметры свойства: TColorDialogOptions; Задает тип окна:
      cdPreventFullOpen отключает выбор дополнительных цветов, отключив кнопку выбора цвета
      cdFullOpen-dialog позволяет выбрать дополнительные цвета сразу при вызове;
      cdShowHelp - завершает диалог с помощью кнопки справки;
      cdAnyColor - позволяет выбирать не только так называемые чистые цвета, но и полутени;
      При работе с цветовыми палитрами cdSolidColor вам необходимо найти цвет в палитре, подобный цвету, выбранному пользователем;
    `,
  },
  {
    title: 'Компоненты отображения графической информации Компоненты PaintBox Shape',
    answer: `В Rad Studio есть компоненты для отображения графики. Вот почему вы столкнулись с компонентами Image, PaintBox, Chart. Однако компонент Shape обычно является средством представления графической информации. Если изображение отображает значки, битовые матрицы и метафайлы, а диаграмма используется для создания диаграмм и графиков, компонент «Форма» используется для рисования различных геометрических фигур, которые рисуются соответствующим образом.
      Компонент Delphi Shape предназначен для рисования простых геометрических фигур в тонированной или монофонической манере.
      Основным свойством этого компонента является Shape, то есть форма, которая может принимать следующие значения:
      1. Прямоугольник stRectangle
      2. Прямоугольный с углом stRoundRect.
      3. эллипс stEllipse
      4. площадь stSquare
      5. stRoundSquare квадрат с прямыми углами
      6. круг stCircle
      Самым важным свойством следующего компонента является кисть. Это свойство является объектом типа TBrush и имеет стиль приведения (Brush.Style) и цвет (Brush.Color) рисунка. Благодаря им ваша фигура будет иметь определенный цвет. Если свойство Color определяет цвет заливки, свойство Style помогает указать образец заливки, а именно штриховку.
      Третье - одно из особых свойств компонента shape-Pen, которое определяет стиль линий. Это свойство, в свою очередь, представляет собой объект с рядом свойств. Одно из них - свойство Color, которое вам известно. Второе свойство - Width.
      Графики и диаграммы компонента Chart
      Компонент Chart позволяет создавать различные диаграммы и графики. Компонент имеет множество свойств, методов, событий.
    `,
  },
  {
    title: 'Графики и диаграммы компонент ТChart',
    answer: `Компонент диаграммы TChartSeries представляет собой контейнер объектов серии серии Series данных, характеризующихся разными стилями отображения. Если вы хотите видеть диаграммы, вы можете объединить несколько разных серий для некоторых типов диаграмм, для других, например круговых диаграмм, это, вероятно, будет выглядеть незаметно. Однако в этом случае вы можете поместить несколько серий одних и тех же данных с разными типами диаграмм для одного и того же компонента Chart. Затем, время от времени активируя одну из них, вы можете позволить пользователю выбрать тип диаграммы, на которой отображается интересующая его информация.
    Это позволяет создать любую страницу редактора диаграмм - многостраничное окно, в котором можно задать все свойства диаграммы. Вы можете вызвать редактор диаграмм, дважды щелкнув компонент Chart или щелкнув правой кнопкой мыши и выбрав Edit Chart во всплывающем меню.
    Если вы хотите попробовать поиграть в программу, дважды щелкните компонент Chart. Вы попадете в окно редактора диаграмм на странице Chart с несколькими закладками. Прежде всего, нам нужна закладка Series. Щелкните Add, чтобы добавить серию. Вы попадете в окно, где можете выбрать диаграмму или тип графики. В этом случае выберите круговую диаграмму pie. Вы можете установить заголовок диаграммы, используя вкладку Titles , вкладка Legend  позволяет указать или удалить легенды диаграммы (список символов), вкладка Panel  позволяет указать тип диаграммы для отображения, закладка 3D позволяет вам изменить внешний вид диаграммы: курсив, прокрутка, толщина и так далее.`,
  },
  {
    title: 'Мультимедийные и иные компоненты отображения информации',
    answer: `Компоненты Animate, MediaPlayer Вставка картин и изображений в приложение. Компонент Image Классы TBitmap, TMetafile, Ticon`,
  },
  {
    title: 'Компоненты Animate MediaPlayer',
    answer: `Компонент Rad Studio Animate расположен на странице палитры компонентов Win32. Он позволяет воспроизводить видеоанимацию AVI (без звука), размер которой не превышает 64 Кбайт и не должен сжиматься в видео. Сам видеоклип не сохраняется вместе с приложением, поэтому при запуске программы вы должны знать, что файл содержит клип на диск.
      Файл клипа загружается с описанием FileName, которое отображает имя файла .AVI. Вы можете определить свойство FileName во время работы приложения. Один демонстрационный файл со средой Rad Studio - cool.avi,
      Компонент Animate содержит стандартные клипы Windows, которые вы можете использовать в своих приложениях. Для этого необходимо присвоить свойству CommonAVI одно из следующих значений:
      Папка search-aviFindFolder;
      Поиск файлов - aviFindFile;
      Компьютерный поиск - aviFindComputer;
      Скопируйте файлы-aviCopyFiles;
      Копировать файл - aviCopyFile;
      Переместить файл в корзину-aviRecycleFile;
      Корзина-aviEmptyRecycle;
      Удалить файл-aviDeleteFile;
      FileName - использовать клип, указанный как aviNone;
    `,
  },
  {
    title: 'Компоненты ProgressBar Gauge',
    answer: `Компонент Delphi ProgressBar позволяет копировать большие файлы, устанавливать приложения на ваш компьютер и многое другое. чтобы показать трудоемкий процесс, такой как
      ProgressBar Свойства
      Max - максимальное значение позиции, соответствующей концу указанного процесса. Процент по умолчанию - 100.
      Min - начальное значение позиции, соответствующей началу отображения процесса.
      Положение, которое может быть установлено во время процесса, начинается с мин и заканчивается макс.
      Установить шаг Step, по умолчанию 10
      Продемонстрируйте плавный непрерывный (действительно) процесс
      Ориентация шкалы компонента ориентации: горизонтальная или вертикальная
      
      Компонент Delphi Gauge расположен на странице палитры компонентов "Шаблоны". Его цель - показать трудоемкие процессы, такие как обработка любых данных, установка приложения на компьютер, копирование больших файлов и так далее. б.
      Компонент "Gauge" имеет следующие свойства:
      MinValue-целочисленный тип (минимальное значение параметра на графике 0%),
      MaxValue - целочисленный тип (максимальное значение параметра на графике - 100%).
      ForeColor устанавливает цвет индикатора. По умолчанию черный.
      BorderStyle устанавливает внешний вид кадра - bsSingle - компонент окружен рамкой, bsNone-frame отсутствует.
      BackColor - цвет части графика без индикатора (по умолчанию белый).
      Progress - это целочисленный тип, который показывает текущий статус индикатора в процентах.
      Show Text - это логический тип, значение ИСТИНА представляет текстовую информацию на диаграмме. Ложные цифры в процентах не видны.
    `,
  },
  {
    title: 'Методы класса Tcanvas',
    answer: `Rad Studio использует специальный класс TCanvas для создания различных элементов управления. Выделяют 4 основных направления, в которых используется этот класс:
      1. Загрузите и сохраните графику.
      2. Создавайте и сохраняйте новые изображения с помощью пера, кисти и шрифта.
      3. Нарисуйте и / или раскрасьте фигуры, линии, текст.
      4. Объедините изображения.
      Свойства Tcanvas:
      1. свойство Brush: TBrush;
      Это свойство цвета (Brush.Color) и стиля (Brush.Style) заполняет замкнутые формы и фон.
      2. свойство ClipRect: TRect; - только чтение
      Это свойство позволяет получить доступную область изображения. Рисовать за пределами этой области невозможно. Это свойство указывает цвет пера для рисования фигуры или линии.
      Методы:
      1. процедура FillRect (const Rect: TRect);
      Этот метод позволяет заполнить прямоугольную область холста RECT, используя текущее значение кисти Brush.
      2. процедура MoveTo (x, y: целое число);
      Метод позволяет перемещать перо в точку (X, Y).
      3. процедура LineTo (X, y: целое число);
      Метод позволяет рисовать прямую линию, начиная с текущего положения пера и заканчивая точкой (x, y). При рисовании используются текущие настройки пера PEN.
    `,
  },
  {
    title: 'Панель Win32',
    answer: `Этот компонент, как и компонент tpagecontrol, является преемником класса tcustomtabcontrol, который имеет общие функции с набором страниц, но его главное отличие состоит в том, что, несмотря на наличие нескольких корней, только одна страница и только одна клиентская область доступный. То есть пользователь может заменять только корни, но не листы. При замене корней содержимое одного листа, естественно, не меняется автоматически.

      Этот компонент используется, когда необходимо реализовать особо сложную логику такого управления. Содержимое каждой «виртуальной» страницы должно контролироваться программно, т.е. динамически создавать и удалять или делать различные группы элементов и графических изображений невидимыми при переключении между корнями.
    
      TTabControl - это компонент страницы, например картотека или записная книжка. Этот компонент позволяет выбрать нужную страницу из доступного массива. Список страниц - вкладки.
    
      TPageControl - еще один компонент страницы. В отличие от предыдущего, все размещенные на нем страницы являются отдельными составляющими. Чтобы создать страницы в этом компоненте, щелкните его правой кнопкой мыши. Не все визуальные компоненты, размещенные на определенной странице (видимые во время работы приложения), будут доступны при перемещении на другую страницу. Вы можете увидеть пример, выполнив поиск по стандартным файлам Windows.
    `,
  },
  {
    title: 'Компоненты TmaskEdit ,TstaticText',
    answer: `Компонент MaskEdit похож по функциональности и назначению на Edit и LabeledEdit, но имеет одно преимущество - он позволяет вам установить маску для свойства editmask. Это позволяет ограничить ввод текста, гарантируя получение данных без синтаксических ошибок, таких как номера телефонов, контактная информация и т. Д. б. Маска состоит из трех частей, разделенных точкой с запятой ";":
      Первый раздел содержит специальные символы и символы маски, которые разрешено вводить в каждой позиции.
      Второй раздел содержит 1 или 0, т.е. следует ли добавлять символы маски к свойству Text компонента MaskEdit.
      В третьем разделе необходимо указать символ, соответствующий позиции, которая не была введена.
      
      Изучение Delphi естественно начинается со страницы стандартных палитр компонентов. Эта страница содержит стандартные элементы интерфейса для Windows, которые часто используются. В следующей таблице перечислены стандартные компоненты страницы: MainMenu, PopupMenu, Label, Edit, Memo, Button, CheckBox, RadioButon, ListBox, ComboBox, ScrollBar, GroupBox, RadioGroup, Panel, ActionList.
    `,
  },
  {
    title: 'Компоненты',
    answer: `Компонент — составная часть, элемент чего-либо
      Внашем же случае, то компоненты это кнопки текстовые поля и другие элементы работы с программой
    `,
  },
  {
    title: 'Компоненты tlist TpageControl',
    answer: `
      Компонент TPageControl (набор страниц) представляет собой свернутые страницы, и доступ к каждой странице с собственным набором элементов управления осуществляется с помощью корней, которым можно присвоить имя, что определяет содержимое страницы. При работе с Delphi вы всегда будете сталкиваться с этим компонентом. Этот элемент управления удобен тем, что позволяет максимально использовать ограниченное пространство экрана, создавая эффект книги, открывающейся на любой странице.
      Компонент, который изначально был помещен в форму, пуст - он не содержит страниц. Новая страница добавляется из контекстного меню с помощью команды New Page (Создать страницу), есть и другие команды: следующая страница - переход на следующую страницу, предварительный переход к предыдущей странице, которая появляется при щелчке правой кнопкой мыши на странице компонент. Это создает новую форму ttabsheet. На этапе проектирования вы можете переключаться между страницами простым щелчком мыши по корешку. Вы можете разместить компоненты Delphi в клиентской области каждой страницы. Переключение на другую страницу приведет к удалению содержимого клиентской области и отображению компонентов, которые переходят на выбранную страницу.
    `,
  },
  {
    title: 'Построение графиков функции',
    answer: `В свойствач компонента TChart, во вкладке Series (то что снизу) над нажать на кнопку Add. а после надо выбрать нужный тип графика.
      Далее в верхней вкладе Series нужно выбрать внутреннюю вкладку Data Sourc и там надо изменить Random Values на Data Set. А тут можно всё настройть под себя. Кроме этого в первой вкладке сможно так же редактировать график. К примеру Title.
    `,
  },
  {
    title: 'Анимация в EmbarcаderroRadStudio',
    answer: `КОПИЯ С ИНТЕРНЕТА!
      Давайте познакомимся на примерах со средствами анимации графических объектов, которые есть в Delphi, и рассмотрим несколько вариантов, как в Delphi быстро реализовать практически любые нетривиальные потребности заказчика.

      Уверен, что все уже заметили, насколько часто в последние годы мы сталкиваемся с таким явлением, как «Тыж<…>» — Тыжврач, Тыжучитель, Тыжархитектор и много еще таких же «Тыж..» — Generics, которые должны знать и уметь все, что по мнению друзей и знакомых входит в область их деятельности.

      Недавно мне повезло узнать, что я — «ТЫЖПРОГРАММИСТ!» и даже с восклицательным знаком!. Этот знак, в конечном счете, вынудил меня срочно заняться тем, чем никогда раньше не приходилось — анимацией в пользовательском интерфейсе.

      Приятель раскритиковал все существующие индикаторы работы  на мобильных устройствах — все эти песочные часы, прогресс-бары, секторные и другие «бабочки». Для его задачи нужен только индикатор в виде карманных часов с вращающимися в них шестеренками.

      И правда, в современных мобильных приложениях пользовательский интерфейс и привлекательность внешнего представления имеют определяющую роль, а успех приходит к приложениям с удобным и оригинальным воплощением пользовательских функций.

      Так или иначе, давайте откроем Delphi и создадим приложение, которое будет передвигать окружность по внутренней поверхности другой окружности, вращаясь по мере движения — как основу для «часиков».

      Как всегда в информатике, все можно сделать тремя-пятью и более способами. Для начала, покажу способ, предложенный Всеволодом Леоновым — потерянной нами Delphi-звездой, непререкаемым для меня авторитетом в области 2D и 3D графики. С его разрешения, покажем этот пример, который весьма прост, но прекрасно показывает всю возможную мощь анимации в FireMonkey. 

      VL_clock
      На форму помещены два круга: большой и маленький, вложенный в большой. Для наглядности внутрь малого круга помещен еще меньший квадрат. Параметрически движение по окружности можно задать при помощи пары sin / cos функций. Поэтому для горизонтали и вертикали используются по 2 анимации типа TFloatAnimation, у которых установлена синусоидальная интерполяция.

      Все волшебство кроется в настройках этих компонент.
      Circle1: TCircle

          Size.Width = 400

          Size.Height = 400

      Circle2: TCircle

            Size.Width = 80

            Size.Height = 80

      faRotation: TFloatAnimation

              Duration = 5.

              Loop = True

              RotationAngle  StartValue = 0.

              StopValue = 360.

      faX1: TFloatAnimation

              AutoReverse = True

              Enabled = True

              Duration = 4.

              Interpolation = Sinusoidal

              Inverse = True

              OnFinish = faX1Finish

              PropertyName = 'Position.X'

              StartValue = 320.

              StopValue = 160.

      faX2: TFloatAnimation

              AutoReverse = True

              Duration = 4.

              Interpolation = Sinusoidal

              Inverse = True

              OnFinish = faX2Finish

              PropertyName = 'Position.X'

              StartValue = 0.

              StopValue = 160.

      faY0: TFloatAnimation

              Enabled = True

              Duration = 4.

              Interpolation = Sinusoidal

              OnFinish = faY0Finish

              PropertyName = 'Position.Y'

              StartValue = 320.

              StopValue = 160.

      faY1: TFloatAnimation

              AutoReverse = True

              Duration = 4.

              Interpolation = Sinusoidal

              Inverse = True

              OnFinish = faY1Finish

              PropertyName = 'Position.Y'

              StartValue = 0.

              StopValue = 160.

      faY2: TFloatAnimation

              AutoReverse = True

              Duration = 4.

              Interpolation = Sinusoidal

              Inverse = True

              PropertyName = 'Position.Y'

              StartValue = 320.

              StopValue = 160.

      

      Рассмотрим горизонталь:

      faX1 – отвечает за движение из центра вправо и обратно<
      faX2 – отвечает за движение из центра влево и обратно
      Если использовать такую пару, то можно подобрать правильную комбинацию StartValue/StopValue + Inverse (true/false). 

      у каждой анимации выключен Loop (зацикливание, бесконечное повторение);
      у каждой анимации включён AutoReverse (чтобы сделать автоматически «туда-и-обратно»)
      по окончании работы faX1 на событие «конец» включается faX2
      по окончании работы faX2 на событие «конец» включается faX1
      Чтобы синхронизировать эти анимации выполняется простая процедура: попеременно включая-выключая друг друга эти анимации двигают объект:  «из центра вправо и обратно» и «из центра влево и обратно»

      Чуть сложнее с вертикальной анимацией. Тут двумя объектам TFloatAnimation обойтись нельзя, так как начальное положение объекта не в центре, а в нижней точке. Поэтому faY0 – работает с начала и один раз, переводя объект в «центральное положение». За это время объект по горизонтали уже ушёл в крайнюю правую точку. Потом уже пара faY1 и faY2 работает также, как и faX1 и faX2.

      Управление по горизонтали и вертикали должны работать так, что когда по вертикали — крайняя точка, по горизонтали – центральная. И – наоборот.

      Обработчики события OnFinish очень просты

      procedure TForm1.faX1Finish(Sender: TObject);

      begin

        faX2.Start;

      end;

      procedure TForm1.faX2Finish(Sender: TObject);

      begin

        faX1.Start;

      end;

      procedure TForm1.faY0Finish(Sender: TObject);

      begin

        faY1.Start;

      end;

      procedure TForm1.faY1Finish(Sender: TObject);

      begin

        faY2.Start;

      end;

      procedure TForm1.faY2Finish(Sender: TObject);

      begin

        faY1.Start;

      end;
    `,
  },
  {
    title: 'Основы 3D-графики',
    answer: `Построение графиков функции`,
  },
  {
    title: 'Компонент  Timer',
    answer: `Компонент таймера Delphi - это очень простой компонент, который не отображается на экране, но тем не менее Timer Delphi выполняет в программе очень важные функции. Delphi Timer позволяет вводить необходимые паузы между определенными действиями.

      Компонент Ttimer имеет всего четыре свойства и одно событие, а работать с компонентом Delphi Timer очень просто.

      Поместите компонент Delphi Timer в форму. Установите желаемый временной интервал в свойстве Interval (измеряется в миллисекундах). Перейдите на вкладку Events и посмотрите единственное событие, поддерживаемое Delphi Timer: компонент OnTimer. Двойным щелчком по нему или двойным щелчком по самому компоненту мы вводим обработчик событий, созданный средой Delphi, где мы вводим код, который позволяет нам выполнять определенные действия.

      По умолчанию, поскольку для свойства Enabled установлено значение True, таймер работает через временной интервал, установленный в свойстве Interval в программе, то есть выводит событие OnTimer. Необходимые действия выполнены. Иногда запланированные действия должны выполняться не автоматически при запуске программы, а при выполнении любых других действий. В этом случае необходимо установить для свойства Enabled в инспекторе объектов значение False.

      Компонент таймера Delphi не очень точен и не может быть измерен в течение короткого периода времени. Его точность составляет около 50 миллисекунд.
      `,
  },
  {
    title: 'Диалоги выбора цвета Компоненты ColorDialog ColorBox  ColorGrid',
    answer: `Компонент Delphi ColorDialog формирует диалоговое окно User Color Selection, показанное на рисунке 1. Здесь вы можете выбрать цвет из основной палитры, а также открыть дополнительную панель для выбора неосновного цвета. Вы можете добавить выбранный вами цвет к дополнительным цветам, используя кнопку «Добавить в пакет», чтобы сохранить его и использовать в будущем.

      Цвет свойства: TColor; Включает цвет по вашему выбору
      свойство CustomColors: TStrings; Включает выбранные пользователем цвета (до 16 цветов). Каждый формат строки имеет следующее <название цвета> = <шестнадцатеричное значение цвета RGB>, где название цвета от ColorA (первый цвет) до цвета (последний, шестнадцатый цвет). Пример Color = 985345
      TColorDialogOption = (cdFullOpen, cdPreventFullOpen, cdShowHelp, cdSolidColor, cdAnyColor);
      TColorDialogOptions = набор TColorDialogOption;
      Параметры свойства: TColorDialogOptions; Задает тип окна:
      cdPreventFullOpen отключает выбор дополнительных цветов, отключив кнопку выбора цвета
      cdFullOpen-dialog позволяет выбрать дополнительные цвета сразу при вызове;
      cdShowHelp - завершает диалог с помощью кнопки справки;
      cdAnyColor - позволяет выбирать не только так называемые чистые цвета, но и полутени;
      При работе с цветовыми палитрами cdSolidColor вам необходимо найти цвет в палитре, подобный цвету, выбранному пользователем;
    `,
  },
  {
    title: 'Диалоги печати Компоненты  PrintDialоg PrinterSetupDialog PageSetupDialog',
    answer: `Компонент Delphi printdialog создает диалоговое окно печати. Как и все диалоговые окна, мой любимый метод диалогового окна печати - это функция Execute (). В результате на экране компьютера появляется стандартное диалоговое окно, в котором можно выбрать принтер, задать диапазон страниц для печати и количество копий.
      Если «Разобрать по копиям» задано значение «Истина», откроется окно с флажком «Копировать копии».
      FromPage Определяет домашнюю страницу для печати.
      MaxPage Определяет верхнюю границу для свойств FromPage и ToPage.
      MinPage Определяет нижний предел для свойств FromPage и ToPage.
      
      Компонент Tprintersetupdialog создает диалоговое окно настроек принтера в зависимости от типа принтера. Это окно взаимодействует с драйвером принтера и не возвращает никакой информации программе, поэтому его метод Execute является процедурой, а не функцией.
    `,
  },
];
